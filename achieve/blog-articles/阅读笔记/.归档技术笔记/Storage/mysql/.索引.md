# MySQL --- 索引

索引优化是对查询性能优化最有效的手段, 它能将查询性能提高几个数量级.

MySQL中会先在索引中查找对应的值, 然后根据匹配的索引记录找到对应的数据行.

MySQL中索引是在存储引擎层实现, 而不是在服务器层.

- 单列索引
- 多列索引, MySQL只能高效使用索引的最左前缀列, 所以列的顺序非常重要

## B-Tree索引

索引一般使用**B-Tree**来实现, 它能够加快查找数据的速度, 
会先通过索引来查找, 然后去定位数据行. 

InnoDB使用**B+Tree**来实现

B-Tree对索引列进行顺序存储, 适用于一下方式查找

- 全键值匹配查找, 同索引中的所有列进行匹配
- 键值范围查找
- 键前缀查找, 必须从索引的最左列开始匹配, 可以进行全匹配或者范围匹配

B-Tree索引可以用于Order By和Group By.

B-Tree的限制:

- 必须从索引的最左列开始匹配, 否则无法使用索引
- 不能跳过索引中的列, 即必须按照索引列的顺序进行匹配
- 如果查询中有某个索引列的范围查询, 则其右边的所有索引列都无法使用索引优化查找

一般会将选择性高的列放到索引的最前列, 当然也需要考虑值的分布情况.

## 索引

适用场景:

- 小表, 全表扫描比索引更高效
- 中大型表, 索引更高效
- 特大型表, 索引的代价变高, 需要一种技术可以直接区分出查询需要的一组数据, 
而不是一条条匹配, 例如分区技术, 元数据技术等

**索引的选择性: 不重复的索引数/数据表的记录总数, 结果的范围(0, 1], 索引的选择性越高则查询效率越高**

唯一索引的选择性=1

对于BLOB, TEXT或者很长的VARCHAR类型的列, 必须使用**前缀索引**, 
因为MySQL不允许索引这些列的完整长度.
所以需要选择足够长的前缀以保证较高的选择性, 但又不能太长.
即让前缀的选择性接近于完整匹配的选择性.

前缀索引能够使索引更小, 查询更快, 但无法作用于Order By和Group By, 也无法作用于覆盖扫描.

MySQL5.0引入了**索引合并**, 能够作用于表上的多个单列索引, 对每个单列索引的查询结果进行合并.

如果使用**explain**命令看到查询使用了索引合并, 说明表上的索引设计很糟糕, 需要进行优化.

## 聚簇索引

聚簇索引不是一个索引类型, 而是一个数据存储的方式.

聚簇索引将索引和数据行存储在一起, 一个表只能有一个聚簇索引, InnoDB使用主键列作为举措索引的索引列.

如果没有主键列, 则选择非空的唯一键代替; 如果都没有, 则InnoDB隐式定义一个主键.

优点:

- 把相关数据保持在一起, 减少磁盘I/O
- 数据的访问更快

缺点:


使用InnoDB时应该尽可能按照主键顺序插入数据

## 覆盖索引



## Hash索引

基于hash table实现, 只有**精确匹配所有索引列**的查询才有效.

MySQL中只有Memory引擎显示支持Hash索引.

## Reference

- Relational Database Index Design and the Optimizers