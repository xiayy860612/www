# 编译期优化

编译期的操作过程有:
- 前端编译器, 把java文件转为class文件, 例如javac等
- 后端运行编译器(JIT编译器, Just In Time Compiler), 
把class文件的字节码转为机器码的过程
- 静态提前编译器(AOT编译器, Ahead Of Time Compiler), 直接把java文件转为机器码文件

## 前端编译器

以javac为例, 编译过程大致分为:
1. 解析与填充符号表的过程
2. 插入式注解处理器的注解处理过程
3. 语义分析和字节码生成过程

### 解析与填充符号表

解析过程:
1. 词法分析, 将源代码的字符流解析为标记(Token)集合, 
单个字符是编写程序的最小单元, 而标记是编译过程的最小单元, 
关键字, 变量名, 字面量, 运算符都可以成为标记.
2. 语法分析, 根据标记序列构造抽象语法树(AST, Abstract Syntax Tree)的过程,
AST是一种描述程序代码语法结构的树形表示, 每个节点代表程序代码中的一个语法结构
3. 填充符号表, 符号表(Symbol Table)是一组符号地址和符号信息构成的表格, 
符号表中的信息在编译的不同阶段都要用到.

符号表的作用:
- 在语义分析阶段, 符号表的内容用于语义检查和中间代码的生成
- 在目标代码生成阶段, 当对符号名进行地址分配时, 符号表是地址分配的依据

### 注解处理器

JDK 1.5加入了对注解(Annotation)的支持, 
JDK 1.6中实现了JSR-269规范, 提供了插入式注解处理器的标准API, 
支持在编译期间对注解进行处理, 通过他们可以修改AST上的任意元素.

要实现注解处理器的代码需要继承**javax.annotation.processing.AbstractProcessor**,
它是执行注解处理器代码时要调用的过程, 
其中参数annotations表示该注解处理器要处理的注解集合, 
参数roundEnv表示本次Round中的语法树节点(Element),
实例变量processingEnv表示注解处理器的上下文, 通过生成新的节点来修改AST.

每个注解处理器在运行时都是**单例的**.

### 语义分析与字节码生成

语法分析之后, 编译器获取到了AST, 
语法树能表示一个结构正确的源程序的抽象, 但无法保证源程序是符合逻辑的.
语义分析的主要任务是对结构上正确的源程序进行上下文有关的审查.

javac中的语义分析过程分为:
1. 标注检查检查的内容包括变量使用前是否已被声明, 
变量与赋值之间的数据类型是否匹配, 常量折叠等
2. 数据及控制流分析, 对程序上下文逻辑进一步的验证, 包括
程序局部变量在使用前是否有赋值, 方法的每条路径是否都有返回值, 
是否所有的受查异常都被正确的处理了等.
3. 解析语法糖(Syntactic Sugar)

局部变量声明为final对运行期是没有影响的, 变量的不变性仅由编译器在编译期间进行保障.

## 语法糖

- 泛型与类型擦除, 泛型技术分为:
  - 基于类型膨胀方法实现的真实泛型, 例如C#
  - 基于类型擦除的伪泛型, 例如Java
- 自动装/拆箱, 鉴于包装类的==运算在不遇到算术运算的情况下不会自动拆箱, 
以及equal()方法不处理类型转换
- 遍历循环
- 条件编译

## Reference

- [Java-JSR-269-插入式注解处理器](https://liuyehcf.github.io/2018/02/02/Java-JSR-269-%E6%8F%92%E5%85%A5%E5%BC%8F%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/)