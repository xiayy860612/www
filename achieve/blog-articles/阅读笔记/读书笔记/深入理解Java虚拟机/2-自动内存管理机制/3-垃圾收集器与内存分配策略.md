# 垃圾收集器与内存分配策略

如何确定对象是否依旧存活:
- 引用计数算法
- 可达性分析算法, 通过检查以GC Roots为起始点的的引用链

GC Roots的对象:
- 虚拟机栈中引用的对象, 即栈帧中的本地变量表
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象, 即Native方法应用的对象

Java中的引用, 从强到弱:
- 强引用(Strong reference), 一般new出来的对象
- 软引用(Soft reference), 有用但非必需的对象, 使用SoftReference来实现.
在系统发生内存溢出之前, 会对这些对象进行回收, 
若内存还是不足, 才抛出内存溢出异常.
- 弱引用(Weak reference), 有用但非必需的对象, 使用WeakReference来实现.
只能生存到下一次垃圾收集发生之前.
- 虚引用(Phantom reference), 一个对象是否有虚引用的存在, 
完全不会对其生存时间构成影响, 也无法通过虚引用获取一个对象实例.
唯一目的是在这个对象被回收时能收到一个系统通知.
使用PhantomReference来实现.

要宣告一个对象死亡, 至少要经历2次标记过程:
1. 进行可达性分析后发现没有与GC Roots相连接的引用链, 
会被第一次标记并进行**是否有必要执行finalize()方法**的筛选
2. 如果有必要执行finalize()方法, 对象会被放到F-Queue的**即将回收**队列中,
jvm会建立finalizer线程去执行每个对象的finalize()方法, 
如果对象在finalize()方法中没有逃脱, 
则GC会对即将回收的对象进行**二次标记**, 之后就真的要被回收.

一个对象的**finalize()方法**最多只会被jvm自动调用**一次**.
而且**finalize()方法是对象逃脱真正被回收的最后机会**, 
只要重新与引用链上的任何一个对象建立关联, 
则在GC进行二次标记时, 它将被移出F-Queue的**即将回收**队列.

## 垃圾回收

垃圾回收算法:
- 标记-清除(Mark-Sweep)算法, 垃圾回收算法的基础
- 复制(copying)算法
- 标记-整理(Mark-Compact)算法
- 分代收集(Generational Collection)算法, 
一般将Java堆分为新生代和老年代, 根据各个年代的特点采用合适的回收算法.
新生代一般选择复制算法, 而老年代选择标记-整理算法.

从GC Roots开始的可达性分析要求必须在一个能**确保一致性的快照**中进行, 
即GC进系分析时必须停顿所有的Java执行线程.

可作为GC Roots的节点只要为全局性引用(如常量或静态变量)和执行上下文(栈帧中的本地变量).

目前主流的Java虚拟机使用的都是**准确式GC**, 所以当执行系统停顿下来时, 
不需要一个个检查玩所有执行上下文以及全局引用, 
而是有办法直接得到哪些地方存放着对象引用.

程序只有到达**安全点(Safepoint)**时才能进行GC.
安全点的选定基本上是以程序`是否具有让程序长时间执行的特征`为标准进行选定.

安全区域(Safe Region)是指在一段代码片段之中, 引用关系不会发生变化, 
在这个区域中的任意地方开始GC都是安全的.

### 垃圾回收器

![](HotSpot虚拟机的垃圾收集器.png)

HotSpot中的垃圾收集器:
- Serial, 用于新生代, 最基本, 发展历史最悠久的收集器, 单线程
- ParNew, 用于新生代, Serial多线程版本
- Parallel Scavenge, 用于新生代, 吞吐量优先收集器
- Serial Old(MSC), 用于老年代, Serial的老年代版本
- Parallel Old, 用于老年代, Parallel Scavenge的老年代版本
- CMS, 用于老年代, 并发低停顿收集器
- G1, 面向服务端应用的垃圾回收器

收集器一般关注与尽可能缩短垃圾收集时用户线程的停顿时间

Serial在执行垃圾回收时, 会暂停其他所有的工作线程.
它对于运行在Client模式下的虚拟机来说是一个很好的选择.

ParNew默认开启的收集线程的数量与CPU的数量相同, 
可通过参数`XX:ParallelGThreads`来控制.

Parallel Scavenge和ParNew类似, 但它的关注点在于达到一个可控制的吞吐量, 
即吞吐量=运行用户代码时间/(运行代码时间+GC回收时间).
适合在后台运算而不需要太多交互的任务.
并且它拥有**GC自适应调节策略(GC Ergonomics)**, 
可以根据当前系统的运行情况收集性能监控信息, 
动态调节各种参数以提供最合适的停顿时间或者最大吞吐量.

CMS收集器对CPU资源非常敏感, 默认启动的回收线程数为`(CPU数量+3)/4`.
CMS收集器无法处理浮动垃圾(Floating Garbage), 
可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生.

浮动垃圾是指在CMS并发清理阶段用户线程产生的新垃圾, 
这些垃圾无法在当次GC过程中进行清理, 需要留到下一次GC时再做清理.
所以CMS在垃圾收集阶段需要在老年代内存中预留足够的内存空间供用户线程使用.
通过设置`XX:CMSInitiatingOccupancyFraction`来指定触发GC的百分比,
如果CMS运行期预留给用户线程的内存不足, 则会出现**Concurrent Mode Failure**失败, 
触发jvm的后备方案, 即临时启动**Serial Old**来对老年代进行GC, 这样停顿时间就会很长.

G1的特点:
- 并行与并发
- 分代收集
- 空间整合
- 可预测的停顿

在使用G1收集器时, Java堆的内存布局与其他收集器有很大的不同, 
它将整个Java堆划分为多个大小相等的独立区域(Region),
而新生代和老年代也不再是物理隔离, 都是一部分Region的集合.
G1跟踪各个Region里垃圾堆积的价值大小(回收所获得的空间以及回收所需要的时间),
优先回收价值最大的Region, 即Garbage-First, 
这保证了G1在有限的时间内可以获取尽可能高的收集效率.

## 内存分配

内存分配策略会因为选择的垃圾回收器的不同而有所不同, 
一般情况的内存分配策略:
1. 对象优先在新生代的Eden上分配, 当Eden不足时, jvm会发起一次Minor GC.
2. 大对象直接进入老年代, 大对象指需要大量连续内存空间的Java对象,
可以通过`-XX:PretenureSizeThreshold`令大于这个参数值的对象直接在老年代分配.
3. 长期存活的对象将进入老年代
4. 动态对象年龄判定
5. 空间分配担保, 在Minor GC之前jvm会检查老年代最大可用的连续空间是否大于新生代所有对象的空间, 来决定是否执行Minor GC, 或者是执行一次Full GC.

- Minor GC, 发生在新生代上的垃圾回收, 因为Java对象大多很快死亡, 
所以Minor GC非常频繁, 一般回收速度也很快
- Major GC/Full GC, 发生在老年代的垃圾回收, 
出现Major GC一般也会出发至少一次Minor GC, 
Major GC速度一般会比Minor GC慢10倍以上.

大对象对jvm的内存分配来说是一个坏消息, 
因为经常出现的话会导致内存还有不少空间时就提前出发垃圾收集, 
以获取足够的连续空间来安置打对象.

长期存活对象的内存区域的迁移: 
1. 在新生代的Eden创建
2. 经历过第一次Minor GC仍然存货, 并且能够被Survivor容纳, 
则移动到新生代的Survivor, 设置对象年龄为1.
3. 对象在Survivor中每经历一次Minor GC并且存活, 则对象年龄递增1
4. 当对象年龄到达进入老年代的阀值时, 就被移动到老年代, 
阀值通过`-XX:MaxTenuringThreshold`来设置.

如果Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一般, 
则年龄大于或者等于该年龄的对象就可以直接进入老年代, 
无需等待MaxTenuringThreshold要求的年龄.

JDK 6 Update 24之后, 如果老年代最大可用的连续空间大于新生代所有对象的总空间
或者历次晋升的平均大小, 那么就会执行Minor GC, 否则执行Full GC.

DirectMemory只会在等待老年代满了之后Full GC时顺便帮它清理掉内存中的废弃对象,
而NIO操作会使用到DirectMemory内存.

## Reference

- [JVM client模式和Server模式的区别
](https://blog.csdn.net/liuxiao723846/article/details/50721183)
-[并发与并行的区别](https://www.jianshu.com/p/b11e251d3dc7)