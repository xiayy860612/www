# Java内存区域与内存溢出异常

![](Java虚拟机运行时数据区.png)

Java虚拟机的多线程通过线程轮流切换并分配处理器执行时间来实现,
任何一个确定时刻, 一个处理器只会执行一条线程中的指令.

## Java的数据区域

### 线程隔离的数据区

生命周期和线程相同, 随着线程的结束而结束.

- 程序计数器， 是**当前线程**所执行的字节码的**行号**指示器， 
字节码解释器通过改变计数器的值来选取下一条字节码指令;
如果正在执行的是native的方法, 计数器的值为空(undefined);
Java虚拟机规范对它指出任何OOM的情况.
- Java虚拟机栈, 描述了Java方法执行的内存模型: 
每个方法在执行的同时会创建一个栈帧, 
用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息,
每个方法从**调用到执行完成**的过程就是一个栈帧在虚拟机栈中**入栈到出栈**的过程.
  - 局部变量表, 存放**编译期确定**的各种基本数据类型, 
  对象引用和returnAddress类型, 分配的大小是确定的并且在运行时不会改变.
- 本地方法栈, 为虚拟机中用到的native方法服务.

### 线程共享的数据区

- Java堆, 为绝大部分的对象实例分配内存, 
是垃圾收集器管理的主要区域, 所以也被称为GC堆
- 方法区, 存储jvm加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等.
  - 运行时常量池
- 直接内存, 不是jvm运行时数据区的一部分, 
主要用于nio类, 它引入了一种基于通道与缓冲区的I/O方式, 
可以使用Native函数直接分配堆外内存, 然后通过一个存储在Java堆中的DirectByteBuffer对象, 
来对这块直接内存的进行操作, 避免在Java堆和Native堆中来回复制数据, 显著的提高了性能

### Java堆

由于现在收集器一般都采用**分代收集算法**, 所以Java堆还可以细分为:

- 新生代
  - Eden空间
  - From Survivor空间
  - To Survivor空间
- 老年代
- 划分出线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)

## Java对象的创建

1. 检查new指令的参数是否能在常量池中定位到一个类的符号引用, 
并检查该符号引用代表的类是否已经加载, 解析和初始化, 
如果没有, 必须先执行类加载过程.
2. 分配内存
  - 指针碰撞(bump the pointer)
  - 空闲列表(free list)
3. 将分配的内存初始化为0
4. 对对象进行必要的设置, 例如类的元数据, hash, GC分代年龄等,
存储在对象头中.
5. 执行对象的构造函数 

分配内存采用的同步手段:
- CAS + 失败重试, 保证更新操作的原子性
- 将内存分配操作按照线程划分到不同的空间中执行, 即每个线程预先分配TLAB.
在TLAB上进行内存分配, 只有到TLAB用完并分配新的TLAB时, 才需要同步锁定.
jvm可以通过`-XX:+/-UseTLAB`来开启和关闭TLAB.

### Java对象的内存布局

- 对象头
  - Mark Word, 存储对象自身的运行时数据, 与对象自身定义的数据无关
  - 类型指针, 指向类的元数据, jvm通过它来确定对象是哪个类的实例
- 实例数据, 对象真正存储的有效信息, 即程序中定义的字段内容, 
存储顺序受虚拟机分配策略和在源码中定义的顺序影响.
- 对齐填充, 只做填充用的占位符

java对象的访问方式:
- 句柄, 通过句柄池来访问对象的实例数据
- 直接指针, 直接访问实例数据

## OutOfMemoryError的常见场景

### Java堆溢出

只要不断的创建对象, 并且**GC Roots到对象之间有可达路径**来避免垃圾回收机制来清楚这些对象, 
那么当对象达到堆的最到上限时, 就会产生内存溢出异常.

解决方案:

1. 通过内存分析工具对dump出来的内存文件进行分析, 
确认是内存泄漏(memory leak)还是内存溢出(memory overflow)
2. 内存泄漏, 即不必要的对象依旧存在, 
通过查看泄漏对象到GC Roots的引用链来确定泄漏的代码位置
3. 内存溢出, 查看虚拟机堆参数(-Xms, -Xmx), 与物理内存进行对比, 看是否可以调大

### 虚拟机栈和本地方法栈溢出

- 线程申请的栈空间大于虚拟机所允许的最大深度, 将抛出StackOverflowError
- 虚拟机在扩展栈时, 无法申请到足够的内存空间, 抛出OutOfMemoryError

操作系统分配给每个进程的内存是有限的, 
jvm通过参数来控制Java堆和方法区的内存的最大值,
所以忽略程序计数器消耗的内存, 虚拟机栈和本地方法栈的总共可用内存为
`进程的内存 - 最大堆内存容量(-Xmx) - 最大方法区内存容量(-XX:MaxPermSize)`.

所以每个线程分配到的栈容量越大, 可以建立的线程数量就越少, 
建立线程时就越容易把剩下的内存耗尽.

如果由于过多线程导致内存溢出, 在不能减少线程数的情况下, 
就只能通过减少最大堆内存和减小每个线程的栈容量来解决.

### 方法区和运行时常量池溢出

运行时动态的生产大量的类, 填满方法区, 导致溢出.

在使用CGLib或者动态语言中比较容易出现, 需要注意类的回首, 但类的回收规则往往比较严苛.

### 本机直接内存溢出

DirectMemory容量可通过-XX:MaxDirectMemorySize来制定, 
否则默认与Java堆最大值一样.

如果dump出来的文件很小, 而程序又直接或间接使用了NIO类, 则有可能是因为直接内存溢出导致.

## Reference

- [Java虚拟机规范]()
- [CGLib](https://github.com/cglib/cglib)