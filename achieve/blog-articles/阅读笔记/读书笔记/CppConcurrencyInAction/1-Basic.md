# Basic


并发(Concurrency), 同时执行多个独立的任务, 即使是在单核机器上也可以, 
可通过时间分片(time-slicing)/任务切换(task switching).

并行(Parallelism), 同时运行多个独立线程, 无法再单核机器上运行.

并发(Concurrency)和并行(Parallelism)的区别,
参考[Concurrency vs Parallelism - What is the difference?](https://stackoverflow.com/questions/1050222/concurrency-vs-parallelism-what-is-the-difference).

---

## 并发的两种基本途径

- 多个单线程的进程
- 单进程多线程

### 多个单线程的进程

缺点:

- 进程间通信, 复杂, 速度慢, 因为操作系统提供了一定的保护措施,避免一个进程去修改另一个进程的数据
- 创建进程的开销, 需要时间启动进程, 需要操作系统的内部资源来管理进程, ...
 
优点:

- 由于系统提供的附加保护操作以及通信机制, 更容易编写**安全**的并发代码
- 可以跨网络进行连接通信, 在不同机器上运行进程, 以低成本的方式提高并行的可扩展性和性能
 
### 单进程多线程

进程中的所有线程共享地址空间, 可以访问到大部分的数据: 全局变量, 指针, ...

缺点:

- 线程间数据共享的安全性低, 需要做大量的工作才能保证数据的安全性.

优点:

- 使用多线程的开销要远小于多进程, 因为地址空间共享以及缺少线程间数据的保护, 使操作系统的记录工作减小.


C++标准并未对进程间通信提供任何原生支持, 所以使用多进程的方式会依赖于平台相关的API.

C++的并发往往使用多线程的方式来实现.

## 分治和性能

使用并发的主要原因: **分治和性能**.

分治, 分离不同的功能模块, 使程序更易理解和测试.

并发的程序往往相对难以理解, 所以如果并发所得到的提升很低时, 不建议使用并发,
即收益比不上成本.

线程是有限的资源, 它会消耗操作系统的资源. 
每个线程都需要独立的**堆栈空间**, 所以运行太多的线程会耗尽进程的**可用内存或地址空间**.

对于32bit的系统架构,进程的可用地址空间为`2^2 * 2^10 * 2^10 * 2*10 = 4GB`.

运行越多的线程, 操作系统需要做越多的上下文切换, 这会耗费本可以花在有价值工作上的时间.

