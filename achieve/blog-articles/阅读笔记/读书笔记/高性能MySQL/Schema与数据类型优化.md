# Schema与数据类型优化

良好的逻辑设计和物理设计时高性能的基石.

尽量避免使用NULL, 尤其是用于索引的列

## 数据类型

数字:

- 整数
    - tinyint/smallint/mediumint/int/bigint, unsigned可选
- 实数
    - Float/Double, 浮点计算
    - DECIMAL, 存储精确的小数, 一般可使用bigint来代替decimal, 通过乘以相应的倍数即可

字符串:

- 字符
    - char, 定长, 适合更新频繁的列或者长度固定的列
    - varchar, 变长, 需要额外的1或2个字节来存储长度, 小于等于255则1个字节, 大于则2个字节; 不适合更新频繁的列, 会导致碎片化
    - text
- 二进制
    - binary
    - varbinary
    - blob

时间:

- datetime, 从1001到9999年, 精度为秒, 把日期和时间封装到格式为**YYYYMMDDHHMMSS**的整数中, 显示与时区无关, 使用8字节存储
- timestamp, 同unit时间戳, 从新纪元时间(1970-01-01T00:00:00)以来的秒数, 使用4字节存储, 只能表示1970到2038年, 显示依赖于时区, 会根据时区不同, 显示对应的时间; 对应的列默认为NOT NULL.

## id列

**整数通常是id列最好的选择**

随机值会分布在很大的空间中, 导致insert和select变慢.
因为插入值会随机写到索引的不同位置, 导致insert语句变慢;
由于数据分布在很大的空间中, 也就导致了select指定的数据会变慢;
还会导致缓存失效.

**按顺序的插入能够保证数据很快插入, 并保证数据集中在一定的范围之内.
递增插入是比较好的选择.**

### 特殊类型处理

**uuid**, 移除'-' => 使用unhex()转换uuid为16 bytes的数字, 存储到binary(16)列中 => 使用hex来解析得到uuid的值

```
mysql> select uuid();
+--------------------------------------+
| uuid()                               |
+--------------------------------------+
| e8dc60bb-6df3-11e8-8915-0800273063ab |
+--------------------------------------+
1 row in set

mysql> select unhex('e8dc60bb6df311e889150800273063ab');
+-------------------------------------------+
| unhex('e8dc60bb6df311e889150800273063ab') |
+-------------------------------------------+
| ��`�m��
+-------------------------------------------+
1 row in set

mysql> select hex(unhex('e8dc60bb6df311e889150800273063ab'));
+------------------------------------------------+
| hex(unhex('e8dc60bb6df311e889150800273063ab')) |
+------------------------------------------------+
| E8DC60BB6DF311E889150800273063AB               |
+------------------------------------------------+
1 row in set

```

**ip地址**, 使用无符号整数存储, 使用inet_aton将ip转换为数字, 使用inet_ntoa将数字转换为ip

```
mysql> select inet_aton('192.168.0.1');
+--------------------------+
| inet_aton('192.168.0.1') |
+--------------------------+
|               3232235521 |
+--------------------------+
1 row in set

mysql> select inet_ntoa(3232235521);
+-----------------------+
| inet_ntoa(3232235521) |
+-----------------------+
| 192.168.0.1           |
+-----------------------+
1 row in set

```

## schema

MySQL的存储引擎API需要在服务器曾和存储引擎层之间通过**行缓冲**格式拷贝数据, 
然后在服务器层将缓冲内容解码成各个列.

- 避免太多的列, 从行缓冲中将编码过的列转换成行数据结构的代价是很高的, 这个代价依赖于列的数量
- 避免太多的关联, MySQL限制了最多只能关联61张表
- 一般情况下可以使用默认值来替换NULL
- 针对写密集的场景, 尽量对schema进行**范式化**设计
- 针对统计数据, 可以使用**不严格的计数或者通过小范围查询填满间隙进行累加的严格计数**来实现, 因为实时计算统计数据时很昂贵的.
- 通过影子表来重建表, 保证在重建的过程中老的表依然可用, 当新表创建完成后和老表进行切换即可; 即使出现问题也可以快速回滚.
    - 创建和老表相同结构的新表, `create table test_table_new like test_table`
    - 填充数据到新表
    - 切换新表和老表, `rename table test_table to test_table_old, test_table_new to test_table`
- 可以使用第三方工具(例如Flexviews)提供的物化视图功能来加速查询, mysql本身不提供物化视图功能
- 计数器表为了增大并发更新性能, 可通过将技术结果保存在多行, 每次随机更新其中一条, 读取时进行汇总即可

### schema的修改

MySQL中大部分执行alter table来修改表结构的操作都会导致重建表, 即用新的结构创建新表, 将旧表数据导入新表, 最后删除旧表.
这对大表来说需要花费很大的时间和代价.

大部分的alter table操作都会导致MySQL服务中断.
对于在生产环境中修改表结构, 一般可采用以下方法:

- 在备用数据库上修改结构后, 和主库进行切换
- 影子拷贝, 操作同创建影子表的操作; 也可借助一些第三方工具来进行影子拷贝

所有的modify column都会导致表重建, 尽量都使用alter column来修改列

MySQL的frm文件存储着表的结构, 可以通过修改frm文件来修改表结构, 不适用于索引的修改, 
但存在一定的风险, 操作前需要备份数据库, 不推荐

- 创建同旧表相同结构的新表
- 在新表上修改结构, 必须保证新表修改的结构能够兼容旧表
- 执行`flush tables with read lock`, 关闭所有表
- 重命名frm文件来交换两个表的结构
- 执行`unlock tables`来释放锁, 重新打开表

## Reference

- Flexviews提供物化视图功能